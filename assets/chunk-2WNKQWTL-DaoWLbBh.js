const{Channel:d}=__STORYBOOK_MODULE_CHANNELS__,{global:a}=__STORYBOOK_MODULE_GLOBAL__,{logger:s}=__STORYBOOK_MODULE_CLIENT_LOGGER__,{STORY_RENDERED:w,UPDATE_STORY_ARGS:_,RESET_STORY_ARGS:O,UPDATE_GLOBALS:k,FORCE_RE_RENDER:A}=__STORYBOOK_MODULE_CORE_EVENTS__;function g(){let e={setHandler:()=>{},send:()=>{}};return new d({transport:e})}var E=class{constructor(){this.getChannel=()=>{if(!this.channel){let e=g();return this.setChannel(e),e}return this.channel},this.getServerChannel=()=>{if(!this.serverChannel)throw new Error("Accessing non-existent serverChannel");return this.serverChannel},this.ready=()=>this.promise,this.hasChannel=()=>!!this.channel,this.hasServerChannel=()=>!!this.serverChannel,this.setChannel=e=>{this.channel=e,this.resolve()},this.setServerChannel=e=>{this.serverChannel=e},this.promise=new Promise(e=>{this.resolve=()=>e(this.getChannel())})}},l="__STORYBOOK_ADDONS_PREVIEW";function f(){return a[l]||(a[l]=new E),a[l]}var C=f(),S=(e,t)=>e.length===t.length&&e.every((r,o)=>r===t[o]),h=()=>new Error("Storybook preview hooks can only be called inside decorators and story functions.");function v(){return a.STORYBOOK_HOOKS_CONTEXT||null}function c(){let e=v();if(e==null)throw h();return e}function R(e,t,r){let o=c();if(o.currentPhase==="MOUNT"){r!=null&&!Array.isArray(r)&&s.warn(`${e} received a final argument that is not an array (instead, received ${r}). When specified, the final argument must be an array.`);let n={name:e,deps:r};return o.currentHooks.push(n),t(n),n}if(o.currentPhase==="UPDATE"){let n=o.getNextHook();if(n==null)throw new Error("Rendered more hooks than during the previous render.");return n.name!==e&&s.warn(`Storybook has detected a change in the order of Hooks${o.currentDecoratorName?` called by ${o.currentDecoratorName}`:""}. This will lead to bugs and errors if not fixed.`),r!=null&&n.deps==null&&s.warn(`${e} received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.`),r!=null&&n.deps!=null&&r.length!==n.deps.length&&s.warn(`The final argument passed to ${e} changed size between renders. The order and size of this array must remain constant.
Previous: ${n.deps}
Incoming: ${r}`),(r==null||n.deps==null||!S(r,n.deps))&&(t(n),n.deps=r),n}throw h()}function T(e,t,r){let{memoizedState:o}=R(e,n=>{n.memoizedState=t()},r);return o}function u(e,t){return T("useCallback",()=>e,t)}function m(){let{currentContext:e}=c();if(e==null)throw h();return e}function y(){let e=C.getChannel(),{id:t,args:r}=m(),o=u(i=>e.emit(_,{storyId:t,updatedArgs:i}),[e,t]),n=u(i=>e.emit(O,{storyId:t,argNames:i}),[e,t]);return[r,o,n]}export{y as u};
